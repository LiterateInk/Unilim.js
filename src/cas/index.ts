import type { CheerioAPI } from "cheerio";
import type { HttpResponse } from "schwi";
import { HeaderKeys, HttpRequest, HttpRequestMethod, HttpRequestRedirection, send } from "schwi";
import { totp as generate } from "smol-totp";
import { NoCasToken, type OAuth2, type Services, type Tokens, type User } from "./models";
export * from "./models";

export class PendingAuth {
  public readonly isEmailAvailable: boolean = false;
  public readonly isTotpAvailable: boolean = false;
  public solved: boolean;

  /**
   * Extracted hidden fields from received <form> that we'll send back.
   *
   * Most of the properties in there are useless,
   * but for bundle size reasons, we won't filter them out.
   */
  private fields: Record<string, string> = {};

  /** @internal */
  public constructor(
    private document: CheerioAPI
  ) {
    const form = document("form");

    this.solved = form.attr("action") === "/registerbrowser";
    this.extractFields();

    if (!this.solved) {
      const buttons = form.find("button[name=sf]").toArray();

      this.isTotpAvailable = Boolean(buttons.find(
        (button) => button.attribs.value === "totp"
      ));

      this.isEmailAvailable = Boolean(buttons.find(
        (button) => button.attribs.value === "mail"
      ));
    }
  }

  /**
   * Finish authentication sequence.
   *
   * This method will call the `registerbrowser` API to enable
   * persistence and be able to re-authenticate in the future
   * without having to manually solve the 2FA challenge.
   */
  public async finish(): Promise<CAS> {
    if (!this.solved) throw new Error("2fa not solved");

    const key = this.fields.totpsecret?.toUpperCase(); // `?` since it might be undefined!
    if (!key) throw new Error("'totpsecret' is not available");

    const totp = generate(key);
    this.fields.fg = "TOTP_" + totp;

    const body = new URLSearchParams(this.fields);

    const request = new HttpRequest.Builder(CAS.HOST + "/registerbrowser")
      .setRedirection(HttpRequestRedirection.MANUAL)
      .setMethod(HttpRequestMethod.POST)
      .setFormUrlEncodedBody(body)
      .build();

    const response = await send(request);
    const cookies = response.headers.getSetCookie();

    const toKV = (cookie: string): string =>
      cookie.split(";")[0].split("=")[1];

    const lemonldap = cookies.find((cookie) => cookie.startsWith(CAS.COOKIE + "="));
    const llngconnection = cookies.find((cookie) => cookie.startsWith(CAS.PERSIST_COOKIE + "="));

    if (!lemonldap || !llngconnection)
      throw new Error("bad auth");

    return new CAS(
      toKV(lemonldap),
      toKV(llngconnection),
      key
    );
  }

  public async sendEmailCode(): Promise<void> {
    return this.use("mail");
  }

  public async solveWithEmailCode(code: string): Promise<void> {
    return this.solve("mail2fcheck", code);
  }

  public async solveWithTotp(totp: string): Promise<void> {
    await this.use("totp");
    return this.solve("totp2fcheck", totp);
  }

  private extractFields(): void {
    this.fields = {};

    this.document("form").find("input[type=hidden]").each((_, input) => {
      const key = input.attribs.name;
      const value = input.attribs.value || "";

      this.fields[key] = value;
    });
  }

  private async solve(method: string, code: string): Promise<void> {
    this.fields.code = code;
    this.fields.stayconnected = "1"; // in case it is missing.

    const body = new URLSearchParams(this.fields);

    const request = new HttpRequest.Builder(CAS.HOST + "/" + method)
      .setMethod(HttpRequestMethod.POST)
      .setFormUrlEncodedBody(body)
      .build();

    const response = await send(request);
    this.document = await response.toHTML();
    this.extractFields();
    this.solved = true;
  }

  private async use(choice: string): Promise<void> {
    this.fields.sf = choice;
    const body = new URLSearchParams(this.fields);

    const request = new HttpRequest.Builder(CAS.HOST + "/2fchoice")
      .setMethod(HttpRequestMethod.POST)
      .setFormUrlEncodedBody(body)
      .build();

    const response = await send(request);
    this.document = await response.toHTML();
    this.extractFields();
  }
}

export class CAS {
  public static readonly COOKIE = "lemonldap";
  public static readonly HOST = "https://cas.unilim.fr";
  public static readonly PERSIST_COOKIE = "llngconnection";

  public constructor(
    /**
     * Your `lemonldap` session cookie, it is used to perform requests.
     */
    public readonly cookie: string,

    /**
     * A persistence cookie.
     *
     * You can provide this to the {@link restore} method to
     * re-authenticate without needing to manually solve 2FA.
     */
    public readonly connection: string,

    /**
     * TOTP key generated by the persistence cookie.
     * Also needed to re-authenticate without manually solving 2FA.
     */
    public readonly key: string
  ) { }

  /**
   * Try to create a new session with the CAS by trying to obtain
   * the authentication form and submit it.
   *
   * Once created, you'll be given a {@link PendingAuth}
   * instance to continue the authentication process.
   */
  public static async initialize(username: string, password: string): Promise<PendingAuth> {
    const token = await this.getInitialTokenCSRF();

    const body = new URLSearchParams({
      password,
      stayconnected: "1",
      token,
      user: username
    });

    const request = new HttpRequest.Builder(CAS.HOST)
      .setMethod(HttpRequestMethod.POST)
      .setFormUrlEncodedBody(body)
      .build();

    const response = await send(request);
    const document = await response.toHTML();

    // Let's delegate everything to PendingAuth.
    return new PendingAuth(document);
  }

  public static async restore(
    username: string, password: string,
    llngconnection: string, key: string
  ): Promise<CAS> {
    let body: URLSearchParams, request: HttpRequest, response: HttpResponse;

    body = new URLSearchParams({
      password,
      token: await this.getInitialTokenCSRF(),
      user: username
    });

    request = new HttpRequest.Builder(CAS.HOST)
      .setMethod(HttpRequestMethod.POST)
      .setFormUrlEncodedBody(body)
      .setCookie(CAS.PERSIST_COOKIE, llngconnection)
      .build();

    response = await send(request);

    const document = await response.toHTML();
    const token = this.extractTokenCSRF(document);
    if (!token) throw new NoCasToken();

    body = new URLSearchParams({
      fg: "TOTP_" + generate(key),
      token,
      usetotp: "1"
    });

    request = new HttpRequest.Builder(CAS.HOST + "/checkbrowser")
      .setRedirection(HttpRequestRedirection.MANUAL)
      .setMethod(HttpRequestMethod.POST)
      .setFormUrlEncodedBody(body)
      .setCookie(CAS.PERSIST_COOKIE, llngconnection)
      .build();

    response = await send(request);

    const cookies = response.headers.getSetCookie();
    let lemonldap = cookies.find((cookie) => cookie.startsWith(CAS.COOKIE + "="));
    if (!lemonldap) throw new Error("bad persistence");
    lemonldap = lemonldap.split(";")[0].split("=")[1];

    return new CAS(
      lemonldap,
      llngconnection,
      key
    );
  }

  /**
   * Return a new CAS instance by using the provided `cookie`.
   * This might be useful for temporary usage.
   *
   * {@link connection} and {@link key} will be empty strings,
   * you won't be able to restore the session with this method.
   *
   * If you prefer to do a whole authentication process,
   * you might want to use {@link initialize}.
   */
  public static temporary(cookie: string): CAS {
    return new CAS(cookie, "", "");
  }

  private static extractTokenCSRF(document: CheerioAPI): string | undefined {
    const token = document("input[name=token]").attr("value");
    if (token) return token;
  }

  /**
   * Tries to retrieve the CSRF token from the CAS login portal.
   *
   * It retries 5 times before failing: sometimes an information
   * page is shown and we need to refresh the page to dismiss it.
   */
  private static async getInitialTokenCSRF(): Promise<string> {
    const MAX_RETRIES = 5;

    for (let _ = 0; _ < MAX_RETRIES; _++) {
      const request = new HttpRequest.Builder(CAS.HOST).build();
      const response = await send(request);

      const document = await response.toHTML();
      const token = this.extractTokenCSRF(document);

      if (token) return token;
    }

    throw new NoCasToken();
  }

  /**
   * Authorize an user through `/oauth2` route.
   * @returns callback URL with authentication details
   */
  public async authorize(client: OAuth2, challenge = false, state = ""): Promise<URL> {
    const url = new URL(CAS.HOST + "/oauth2/authorize");
    const scopes = client.scopes.join(" ");

    const parameters = url.searchParams;
    parameters.set("redirect_uri", client.callback);
    parameters.set("client_id", client.identifier);
    parameters.set("response_type", "code");
    parameters.set("scope", scopes);
    parameters.set("state", state);

    if (challenge) {
      parameters.set("code_challenge_method", "plain");
      parameters.set("code_challenge", "literateink");
    }

    const request = new HttpRequest.Builder(url)
      .setRedirection(HttpRequestRedirection.MANUAL)
      .setCookie(CAS.COOKIE, this.cookie)
      .build();

    const response = await send(request);

    let location = response.headers.get("location");

    // We're prompted to accept the OAuth2
    if (response.status === 200 && !location) {
      const document = await response.toHTML();
      const confirm = document("#confirm").attr("value");

      if (confirm) {
        const body = new URLSearchParams({
          client_id: client.identifier,
          confirm,
          redirect_uri: client.callback,
          response_type: "code",
          scope: scopes,
          // -> btoa("https://cas.unilim.fr/oauth2")
          url: "aHR0cHM6Ly9jYXMudW5pbGltLmZyL29hdXRoMg=="
        });

        if (challenge) {
          body.set("code_challenge", "literateink");
          body.set("code_challenge_method", "plain");
        }

        const request = new HttpRequest.Builder(url)
          .setMethod(HttpRequestMethod.POST)
          .setRedirection(HttpRequestRedirection.MANUAL)
          .setCookie(CAS.COOKIE, this.cookie)
          .setFormUrlEncodedBody(body)
          .build();

        const response = await send(request);
        location = response.headers.get("location");
      }
    }

    if (!location)
      throw new Error("location header not found");

    return new URL(location);
  }

  /**
   * Authenticates to a given service using the CAS as SSO.
   * Most of the time it'll generate a ticket URL.
   *
   * @param service service to authenticate to through CAS
   * @returns an authenticated url to said service
   */
  public async service(service: Services): Promise<URL> {
    const url = new URL(CAS.HOST + "/cas/login");

    const parameters = url.searchParams;
    parameters.set("service", service);
    parameters.set("gateway", "true");

    const request = new HttpRequest.Builder(url)
      .setRedirection(HttpRequestRedirection.MANUAL)
      .setCookie(CAS.COOKIE, this.cookie)
      .build();

    const response = await send(request);
    const location = response.headers.get("location");
    if (!location) throw new Error("location header not found");

    return new URL(location);
  }

  /**
   * Retrieves CAS tokens using the authorized OAuth2.0 callback URL.
   *
   * @param callback url created with {@link authorize} method
   * @param client oauth2 linked to the url
   */
  public async tokenize(callback: URL, client: OAuth2, challenge = false): Promise<Tokens> {
    const code = callback.searchParams.get("code");

    if (!code)
      throw new Error("no code found");

    const body = new URLSearchParams({
      client_id: client.identifier,
      code,
      grant_type: "authorization_code",
      redirect_uri: client.callback
    });

    if (challenge) {
      body.set("code_verifier", "literateink");
    }

    const request = new HttpRequest.Builder(CAS.HOST + "/oauth2/token")
      .setFormUrlEncodedBody(body)
      .setMethod(HttpRequestMethod.POST)
      .build();

    const response = await send(request);
    return response.toJSON();
  }

  /**
   * Retrieves user information from the CAS.
   *
   * @param tokens oauth2 tokens received in {@link tokenize}
   * @returns user details from CAS
   */
  public async userinfo(tokens: Tokens): Promise<User> {
    const request = new HttpRequest.Builder(CAS.HOST + "/oauth2/userinfo")
      .setHeader(HeaderKeys.AUTHORIZATION, `Bearer ${tokens.access_token}`)
      .build();

    const response = await send(request);

    if (response.status !== 200)
      throw new Error("invalid access token");

    return response.toJSON();
  }
}
